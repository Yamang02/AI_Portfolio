# Duplicate Key 에러 발생 원리 및 해결 방안 다이어그램

## 🔴 문제 상황 시각화

### 1. 현재 문제가 있는 플로우

```
┌─────────────────────────────────────────────────────────────────┐
│ 사용자: 프로젝트 수정 요청                                        │
│ - 프로젝트 ID: PJT001                                            │
│ - 기술 스택: [React, TypeScript, Node.js] → 동일               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ AdminProjectController.updateProject()                          │
│ → ManageProjectService.updateProjectWithRelations()            │
│ → ProjectRelationshipAdapter.replaceTechStacks()               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: 기존 관계 삭제 명령                                      │
│                                                                 │
│   projectTechStackJpaRepository.deleteByProjectId(1);          │
│                                                                 │
│   ⚠️ 문제: 트랜잭션 내에서 즉시 반영되지 않음!                   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 현재 DB 상태 (트랜잭션 버퍼)                                     │
│                                                                 │
│   project_tech_stack 테이블:                                    │
│   ┌────┬────────────┬───────────────┐                          │
│   │ id │ project_id │ tech_stack_id │ ← 아직 살아있음!         │
│   ├────┼────────────┼───────────────┤                          │
│   │ 1  │     1      │      1        │ ← React                  │
│   │ 2  │     1      │      2        │ ← TypeScript             │
│   │ 3  │     1      │      3        │ ← Node.js                │
│   └────┴────────────┴───────────────┘                          │
│                                                                 │
│   DELETE 명령이 버퍼에 대기 중...                               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: 새로운 관계 삽입 시도                                    │
│                                                                 │
│   for (techStackId : [1, 2, 3]) {                              │
│       save(project=1, techStack=1);  // ❌ 중복!               │
│   }                                                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 💥 에러 발생!                                                    │
│                                                                 │
│   ERROR: duplicate key value violates unique constraint        │
│   "project_tech_stack_project_id_tech_stack_id_key"            │
│                                                                 │
│   Detail: Key (project_id, tech_stack_id)=(1, 1)              │
│   already exists.                                               │
└─────────────────────────────────────────────────────────────────┘
```

---

## ✅ 해결 방안 1: 명시적 플러시 (Phase 1)

```
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: 기존 관계 삭제 명령                                      │
│                                                                 │
│   projectTechStackJpaRepository.deleteByProjectId(1);          │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 1.5: ✅ 명시적 플러시 추가                                  │
│                                                                 │
│   projectTechStackJpaRepository.flush();                       │
│                                                                 │
│   → 트랜잭션 버퍼의 DELETE 명령을 DB에 즉시 반영!               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 현재 DB 상태 (플러시 후)                                         │
│                                                                 │
│   project_tech_stack 테이블:                                    │
│   ┌────┬────────────┬───────────────┐                          │
│   │ id │ project_id │ tech_stack_id │                          │
│   ├────┼────────────┼───────────────┤                          │
│   │    │            │               │ ← 비어있음 ✅            │
│   └────┴────────────┴───────────────┘                          │
│                                                                 │
│   DELETE 완료!                                                  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: 새로운 관계 삽입                                         │
│                                                                 │
│   for (techStackId : [1, 2, 3]) {                              │
│       save(project=1, techStack=1);  // ✅ 성공!               │
│   }                                                             │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ ✅ 성공!                                                         │
│                                                                 │
│   project_tech_stack 테이블:                                    │
│   ┌────┬────────────┬───────────────┐                          │
│   │ id │ project_id │ tech_stack_id │                          │
│   ├────┼────────────┼───────────────┤                          │
│   │ 4  │     1      │      1        │ ← React (새 ID)          │
│   │ 5  │     1      │      2        │ ← TypeScript (새 ID)     │
│   │ 6  │     1      │      3        │ ← Node.js (새 ID)        │
│   └────┴────────────┴───────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

**코드 변경**:
```java
// Before
projectTechStackJpaRepository.deleteByProjectId(project.getId());
// INSERT 로직

// After
projectTechStackJpaRepository.deleteByProjectId(project.getId());
projectTechStackJpaRepository.flush();  // ✅ 추가
// INSERT 로직
```

---

## 🎯 해결 방안 2: Merge 전략 (Phase 2)

### 시나리오: 10개 중 2개만 변경

```
┌─────────────────────────────────────────────────────────────────┐
│ 기존 상태                                                        │
│   TechStack IDs: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]              │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 수정 요청                                                        │
│   TechStack IDs: [1, 2, 3, 4, 5, 6, 7, 8, 11, 12]             │
│                                                                 │
│   변경 내역:                                                     │
│   - 삭제: 9, 10                                                 │
│   - 추가: 11, 12                                                │
│   - 유지: 1, 2, 3, 4, 5, 6, 7, 8                               │
└─────────────────────────────────────────────────────────────────┘
```

### Option 1: 전체 교체 (현재 방식)

```
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: 전체 삭제 (10개)                                         │
│                                                                 │
│   DELETE FROM project_tech_stack                                │
│   WHERE project_id = 1;                                         │
│                                                                 │
│   ❌ 10개 모두 삭제 (유지해야 할 8개도 삭제!)                    │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: 전체 삽입 (10개)                                         │
│                                                                 │
│   INSERT INTO project_tech_stack (project_id, tech_stack_id)   │
│   VALUES (1, 1), (1, 2), ..., (1, 11), (1, 12);                │
│                                                                 │
│   ❌ 10개 모두 새로 삽입 (8개는 불필요한 재생성!)                │
└─────────────────────────────────────────────────────────────────┘

총 쿼리: DELETE 10개 + INSERT 10개 = 20개
```

### Option 2: Merge 전략 (개선)

```
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: 기존 관계 조회                                           │
│                                                                 │
│   SELECT * FROM project_tech_stack                              │
│   WHERE project_id = 1;                                         │
│                                                                 │
│   결과: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]                        │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: 차집합 계산 (애플리케이션 레벨)                          │
│                                                                 │
│   기존: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]                        │
│   요청: [1, 2, 3, 4, 5, 6, 7, 8, 11, 12]                       │
│                                                                 │
│   삭제할 것: [9, 10]     (기존 - 요청)                          │
│   추가할 것: [11, 12]    (요청 - 기존)                          │
│   유지할 것: [1, 2, 3, 4, 5, 6, 7, 8]  (교집합)                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 3: 필요한 항목만 삭제 (2개)                                 │
│                                                                 │
│   DELETE FROM project_tech_stack                                │
│   WHERE project_id = 1                                          │
│   AND tech_stack_id IN (9, 10);                                │
│                                                                 │
│   ✅ 2개만 삭제!                                                 │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 4: 플러시                                                   │
│                                                                 │
│   projectTechStackJpaRepository.flush();                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ Step 5: 필요한 항목만 추가 (2개)                                 │
│                                                                 │
│   INSERT INTO project_tech_stack (project_id, tech_stack_id)   │
│   VALUES (1, 11), (1, 12);                                     │
│                                                                 │
│   ✅ 2개만 삽입!                                                 │
└─────────────────────────────────────────────────────────────────┘

총 쿼리: SELECT 1개 + DELETE 2개 + INSERT 2개 = 5개
성능 향상: 75% (20개 → 5개)
```

---

## 📊 성능 비교 그래프

```
전체 교체 방식 (Option 1 - 현재)
━━━━━━━━━━━━━━━━━━━━ DELETE (10개)
━━━━━━━━━━━━━━━━━━━━ INSERT (10개)
총 20개 쿼리


Merge 전략 (Option 2 - 개선)
━━━━ DELETE (2개)
━━━━ INSERT (2개)
총 4개 쿼리

성능 개선: 80% ⬆️
```

---

## 🔍 데이터베이스 제약조건 구조

### UNIQUE 제약조건 상세

```sql
-- V002__add_admin_features.sql

CREATE TABLE project_tech_stack (
    id BIGSERIAL PRIMARY KEY,
    project_id BIGINT NOT NULL
        REFERENCES projects(id) ON DELETE CASCADE,
    tech_stack_id BIGINT NOT NULL
        REFERENCES tech_stack_metadata(id) ON DELETE CASCADE,
    is_primary BOOLEAN DEFAULT FALSE,
    usage_description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    -- ⚠️ 이 제약조건이 문제의 원인!
    UNIQUE(project_id, tech_stack_id)
    -- 동일한 프로젝트에 동일한 기술 스택을 중복 추가할 수 없음
);
```

### 제약조건 위반 시나리오

```
┌─────────────────────────────────────────────────────────────────┐
│ 현재 DB 상태                                                     │
│                                                                 │
│   project_tech_stack 테이블:                                    │
│   ┌────┬────────────┬───────────────┬─────────┐                │
│   │ id │ project_id │ tech_stack_id │ (기타)  │                │
│   ├────┼────────────┼───────────────┼─────────┤                │
│   │ 1  │     1      │      1        │  ...    │ ← 존재        │
│   │ 2  │     1      │      2        │  ...    │                │
│   │ 3  │     1      │      3        │  ...    │                │
│   └────┴────────────┴───────────────┴─────────┘                │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ INSERT 시도                                                      │
│                                                                 │
│   INSERT INTO project_tech_stack                                │
│   (project_id, tech_stack_id)                                   │
│   VALUES (1, 1);  -- ❌ (1, 1)은 이미 존재!                     │
│                                                                 │
│   PostgreSQL 응답:                                              │
│   ERROR: duplicate key value violates unique constraint         │
│   "project_tech_stack_project_id_tech_stack_id_key"            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🛠️ 트랜잭션 타이밍 이슈 설명

### JPA/Hibernate 트랜잭션 처리 순서

```
┌─────────────────────────────────────────────────────────────────┐
│ @Transactional 메서드 시작                                       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 1. Persistence Context 생성                                     │
│    (영속성 컨텍스트 = 1차 캐시 + 쓰기 지연 저장소)               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 2. 엔티티 조회/변경 작업                                         │
│                                                                 │
│    em.remove(entity);  // ← DELETE 명령은 쓰기 지연 저장소에    │
│    em.persist(entity); // ← INSERT 명령도 쓰기 지연 저장소에    │
│                                                                 │
│    ⚠️ 아직 DB에 반영되지 않음!                                   │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 3. 자동 플러시 시점 (다음 중 하나)                               │
│                                                                 │
│    a) 트랜잭션 커밋 직전                                         │
│    b) JPQL 쿼리 실행 직전                                        │
│    c) 명시적 em.flush() 호출 시                                 │
│                                                                 │
│    → 이때 쓰기 지연 저장소의 명령들이 DB에 전송됨!               │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 4. DB에 SQL 실행                                                │
│                                                                 │
│    DELETE FROM project_tech_stack WHERE ...                     │
│    INSERT INTO project_tech_stack VALUES ...                    │
│                                                                 │
│    ⚠️ 이 순서가 보장되지 않으면 UNIQUE 제약 조건 위반!           │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ 5. 트랜잭션 커밋                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 명시적 플러시의 효과

```
┌─────────────────────────────────────────────────────────────────┐
│ deleteByProjectId(1);  // ← 쓰기 지연 저장소에 DELETE 대기      │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ flush();  // ✅ 강제로 지금 DB에 반영!                           │
│                                                                 │
│   → DELETE FROM project_tech_stack WHERE project_id = 1;       │
│   → DB에서 실제로 삭제됨                                         │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│ save(new ProjectTechStack(1, 1));  // ✅ 안전하게 삽입 가능!    │
│                                                                 │
│   → INSERT INTO project_tech_stack VALUES (1, 1);              │
│   → UNIQUE 제약 조건 위반 없음!                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🎯 요약

| 항목 | 문제 | 해결책 (Phase 1) | 개선 (Phase 2) |
|------|------|------------------|----------------|
| **원인** | DELETE와 INSERT가 트랜잭션 버퍼에서 중복 | `flush()` 추가로 DELETE 즉시 반영 | Merge 전략으로 필요한 것만 변경 |
| **쿼리 수** | DELETE 10개 + INSERT 10개 = 20개 | DELETE 10개 + **FLUSH** + INSERT 10개 = 20개 | DELETE 2개 + FLUSH + INSERT 2개 = 4개 |
| **성능** | ⭐⭐ | ⭐⭐ | ⭐⭐⭐⭐⭐ |
| **구현 난이도** | - | ⭐ 쉬움 | ⭐⭐ 보통 |
| **안정성** | ❌ 에러 발생 | ✅ 안정 | ✅ 안정 + 최적화 |

---

**작성일**: 2025-12-16
**작성자**: AI Agent (Claude)
