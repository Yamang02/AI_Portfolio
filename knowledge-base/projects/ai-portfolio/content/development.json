[
  {
    "id": "git-branch-strategy",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "workflow",
    "title": "Git 브랜치 전략",
    "question": "Git 브랜치 전략은?",
    "answer": "Git Flow 기반의 브랜치 전략을 사용합니다:\n\n**브랜치 구조**:\n- **main**: 프로덕션 릴리스 브랜치\n- **staging**: 스테이징 환경 테스트 브랜치\n- **develop**: 개발 통합 브랜치\n- **feature/***: 기능 개발 브랜치\n- **hotfix/***: 긴급 수정 브랜치\n\n**워크플로우**:\n1. feature/xxx → develop (기능 개발)\n2. develop → staging (스테이징 배포)\n3. staging → main (프로덕션 배포)",
    "tags": ["git", "branch-strategy", "git-flow", "workflow"],
    "keywords": ["Git", "브랜치", "전략", "워크플로우", "Git Flow"],
    "difficulty": "intermediate",
    "priority": 8,
    "related_content": ["code-review-process", "ci-cd-integration"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "code-review-process",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "quality-assurance",
    "title": "코드 리뷰 프로세스", 
    "question": "코드 리뷰 프로세스는?",
    "answer": "Pull Request 기반의 체계적인 코드 리뷰를 진행합니다:\n\n**리뷰 체크리스트**:\n- **기능 구현**: 요구사항 충족 여부\n- **코드 품질**: 가독성, 유지보수성\n- **성능**: 불필요한 렌더링, 메모리 누수 체크\n- **보안**: 입력 검증, XSS 방지 확인\n- **테스트**: 단위 테스트 커버리지\n\n**리뷰 가이드라인**:\n- 건설적인 피드백 제공\n- 코드 스타일 일관성 확인\n- 아키텍처 원칙 준수 검토",
    "tags": ["code-review", "pull-request", "quality-assurance", "best-practices"],
    "keywords": ["코드리뷰", "Pull Request", "품질보증", "체크리스트"],
    "difficulty": "intermediate",
    "priority": 9,
    "related_content": ["git-branch-strategy", "code-style-management"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "code-style-management",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "code-quality",
    "title": "코드 스타일 관리",
    "question": "코드 스타일은 어떻게 관리하나요?",
    "answer": "자동화된 도구로 일관성을 유지합니다:\n\n**Frontend (TypeScript/React)**:\n- ESLint: @typescript-eslint, react-hooks 규칙\n- Prettier: 코드 포맷팅 자동화\n- Semi, SingleQuote, TabWidth 설정\n\n**Backend (Java/Spring)**:\n- Checkstyle: Google Java Style Guide 준수\n- SpotBugs: 정적 분석으로 버그 패턴 감지\n- SonarQube: 코드 품질 및 보안 취약점 분석",
    "tags": ["code-style", "eslint", "prettier", "checkstyle", "static-analysis"],
    "keywords": ["코드스타일", "ESLint", "Prettier", "정적분석", "Checkstyle"],
    "difficulty": "intermediate",
    "priority": 7,
    "code_examples": [
      {
        "language": "json",
        "code": "{\n  \"extends\": [\n    \"@typescript-eslint/recommended\",\n    \"plugin:react-hooks/recommended\"\n  ],\n  \"rules\": {\n    \"react-hooks/exhaustive-deps\": \"error\",\n    \"@typescript-eslint/no-unused-vars\": \"error\"\n  }\n}",
        "description": "ESLint 설정 예시"
      }
    ],
    "related_content": ["code-review-process", "testing-strategy"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z", 
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "testing-strategy",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "testing",
    "title": "테스트 전략",
    "question": "테스트 전략은?",
    "answer": "다층적 테스트 피라미드 구조를 사용합니다:\n\n**테스트 레벨**:\n1. **Unit Tests**: 개별 함수/컴포넌트 테스트\n2. **Integration Tests**: 서비스 간 연동 테스트\n3. **E2E Tests**: 사용자 시나리오 테스트\n4. **API Tests**: REST API 엔드포인트 테스트\n\n**테스트 도구**:\n- Frontend: Jest + React Testing Library\n- Backend: JUnit 5 + MockMvc + Testcontainers\n- E2E: Playwright (계획)\n\n**커버리지 목표**: Unit 80%+, Integration 100%",
    "tags": ["testing", "junit", "jest", "test-pyramid", "coverage"],
    "keywords": ["테스트", "단위테스트", "통합테스트", "JUnit", "Jest"],
    "difficulty": "advanced",
    "priority": 9,
    "related_content": ["code-style-management", "development-environment"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "development-environment",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "environment",
    "title": "개발 환경 설정",
    "question": "로컬 개발 환경은 어떻게 구성하나요?",
    "answer": "Docker Compose를 활용한 일관된 개발 환경을 구축했습니다:\n\n**개발 환경 구성**:\n- Frontend: Vite HMR (Hot Module Replacement)\n- Backend: Spring Boot DevTools\n- AI Service: FastAPI auto-reload\n- Database: PostgreSQL + Redis + Qdrant\n\n**핫 리로딩**: 모든 서비스에서 코드 변경 시 자동 재시작",
    "tags": ["development-environment", "docker-compose", "hot-reload", "local-setup"],
    "keywords": ["개발환경", "Docker Compose", "핫리로딩", "로컬환경"],
    "difficulty": "intermediate",
    "priority": 8,
    "code_examples": [
      {
        "language": "yaml",
        "code": "services:\n  frontend:\n    build:\n      context: ./frontend\n      dockerfile: Dockerfile.dev\n    volumes:\n      - ./frontend/src:/app/src\n    ports:\n      - \"5173:5173\"",
        "description": "개발용 Docker Compose 설정 예시"
      }
    ],
    "related_content": ["testing-strategy", "performance-monitoring"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "development-tools",
    "project_id": "ai-portfolio", 
    "type": "qa",
    "category": "development",
    "subcategory": "tools",
    "title": "개발 도구 및 IDE",
    "question": "개발 도구 및 IDE 설정은?",
    "answer": "생산성을 위한 도구 스택을 구축했습니다:\n\n**IDE/Editor**:\n- VS Code: 주 개발 환경\n- IntelliJ IDEA: Java 개발 시 활용\n- 확장 프로그램: ESLint, Prettier, GitLens\n\n**개발 도구**:\n- Postman: API 테스트\n- Docker Desktop: 컨테이너 관리\n- pgAdmin: PostgreSQL 관리\n- Redis Insight: Redis 데이터 확인",
    "tags": ["development-tools", "vscode", "intellij", "postman", "docker"],
    "keywords": ["개발도구", "VS Code", "IntelliJ", "Postman", "IDE"],
    "difficulty": "beginner",
    "priority": 6,
    "related_content": ["development-environment", "documentation"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "documentation",
    "project_id": "ai-portfolio",
    "type": "qa", 
    "category": "development",
    "subcategory": "documentation",
    "title": "문서화 전략",
    "question": "프로젝트 문서화는?",
    "answer": "다층적 문서화 전략을 사용합니다:\n\n**기술 문서**:\n- README.md: 프로젝트 개요 및 설치 가이드\n- API 문서: OpenAPI 스펙 기반 자동 생성\n- 아키텍처 문서: Mermaid 다이어그램 활용\n- 배포 가이드: 단계별 배포 프로세스\n\n**코드 문서**:\n- JSDoc: JavaScript/TypeScript 함수 문서화\n- Javadoc: Java 클래스/메서드 문서화\n- README per feature: 기능별 상세 설명",
    "tags": ["documentation", "readme", "jsdoc", "javadoc", "api-docs"],
    "keywords": ["문서화", "README", "JSDoc", "Javadoc", "API문서"],
    "difficulty": "intermediate",
    "priority": 7,
    "related_content": ["development-tools", "performance-monitoring"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  },
  {
    "id": "performance-monitoring",
    "project_id": "ai-portfolio",
    "type": "qa",
    "category": "development",
    "subcategory": "monitoring",
    "title": "성능 모니터링",
    "question": "개발 중 성능 측정은?", 
    "answer": "지속적인 성능 모니터링을 실시합니다:\n\n**Frontend 성능**:\n- Core Web Vitals: LCP, FID, CLS 측정\n- Bundle Analyzer: 번들 크기 분석\n- Lighthouse: 성능 점수 추적\n- Chrome DevTools: 실시간 프로파일링\n\n**Backend 성능**:\n- Application Metrics: 응답 시간, 처리량 측정\n- JVM Monitoring: 메모리, GC 성능 추적\n- Database Performance: 쿼리 실행 계획 분석\n- Cache Hit Rate: Redis 캐시 효율성 측정\n\n**성능 임계치**: 페이지 로드 3초, API 응답 500ms 이내",
    "tags": ["performance", "monitoring", "lighthouse", "web-vitals", "jvm"],
    "keywords": ["성능", "모니터링", "Lighthouse", "Web Vitals", "JVM"],
    "difficulty": "advanced",
    "priority": 8,
    "related_content": ["development-environment", "testing-strategy"],
    "created_at": "2025-08-25T00:00:00Z",
    "last_updated": "2025-08-25T00:00:00Z",
    "author": "system",
    "version": "1.0"
  }
]