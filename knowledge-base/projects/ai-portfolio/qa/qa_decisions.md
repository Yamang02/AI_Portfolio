---
version: 1.0
valid_from_date: 2025-08-30
category: decisions
---

# 기술 의사결정 Q&A

이 문서는 AI 포트폴리오 프로젝트의 주요 기술적 의사결정과 근거를 정리합니다.

---

### Q: 헥사고널 아키텍처로 전환한 이유는?

> **결정사항**: Clean Architecture에서 헥사고널 아키텍처(Ports and Adapters)로 전환
> 
> **기존 문제점**:
> - `app/main.py` + `presentation/api/` 구조로 import 경로 혼란
> - 여러 데모 버전 혼재 (`app/demo/`, `presentation/demo/`, HuggingFace용)
> - DTO와 Entity 모델이 섞인 구조
> - `sys.path` 조작 등 임시방편적 해결책
> 
> **헥사고널 아키텍처 선택 근거**:
> - ✅ **명확한 의존성 방향**: Primary (들어오는) vs Secondary (나가는) 어댑터
> - ✅ **FastAPI와 완벽 매치**: 의존성 주입이 자연스럽게 헥사고날과 연동
> - ✅ **실용적 구조**: 오버엔지니어링 없이 깔끔함
> - ✅ **확장성**: 새로운 어댑터 추가가 용이
> 
> **결과**: 
> - 순환 의존성 해결
> - 코드 구조 단순화 및 가독성 향상
> - 테스트 용이성 확보

---

### Q: 백엔드 JPA Entity 구조를 단순화한 이유는?

> **결정사항**: 3층 구조에서 2층 구조로 단순화
> 
> **기존**: Domain Model ↔ DB Schema Entity ↔ JPA Entity (3층)
> **개선**: Domain Model ↔ JPA Entity (2층)
> 
> **단순화 근거**:
> - **불필요한 복잡성 제거**: 중간 매핑 레이어의 오버헤드
> - **실용적 접근**: 이론보다는 실제 개발 효율성 우선
> - **유지보수성**: 적은 파일 수로 관리 부담 감소
> 
> **삭제된 파일들**:
> - ProjectEntity.java, ExperienceEntity.java, EducationEntity.java, CertificationEntity.java
> 
> **결과**:
> - 코드베이스 20% 감소
> - 새 기능 추가 시 수정 파일 수 절반으로 감소
> - 개발 생산성 향상

---

### Q: 배포 환경별 보안 전략을 다르게 설정한 이유는?

> **결정사항**: Staging과 Production 환경의 차별화된 CI/CD 전략
> 
> **Staging 환경**:
> - 완전 자동화 + 높은 권한 (postgres 사용자)
> - CI/CD에서 자동 마이그레이션 실행
> - 빠른 개발 및 테스트 피드백 우선
> 
> **Production 환경**:
> - 수동 배포 + 제한된 권한 (ai_portfolio_app 사용자)
> - 마이그레이션: postgres 사용자로 수동 실행
> - 애플리케이션: DML 권한만 (SELECT, INSERT, UPDATE, DELETE)
> 
> **결정 근거**:
> - **최소 권한 원칙**: Production에서 보안 강화
> - **개발 효율성**: Staging에서 빠른 피드백 루프
> - **실무 모범 사례**: 환경별 차별화된 보안 정책
> - **CI/CD 복잡도 균형**: 보안과 효율성의 절충점

---

### Q: GitHub API 중심 데이터 관리 방식을 선택한 이유는?

> **결정사항**: constants.ts 하드코딩에서 GitHub API 동적 로딩으로 전환
> 
> **이전 방식의 문제점**:
> - 프로젝트 정보 업데이트 시마다 코드 수정 필요
> - 버전 관리와 실제 프로젝트 상태 불일치
> - 수동 동기화 작업 필요
> 
> **GitHub API 방식 선택 근거**:
> - ✅ **단순하고 효율적**: 복잡한 API 참조 시스템 제거
> - ✅ **실시간 동기화**: GitHub 변경사항 자동 반영
> - ✅ **캐시 전략**: 24시간 유효기간으로 성능과 최신성 균형
> - ✅ **폴백 메커니즘**: GitHub API 실패 시 기본 데이터 제공
> 
> **구현 방법**:
> - ProjectService 클래스로 통합 관리
> - README는 GitHub API에서 동적 로딩
> - 복잡한 API 참조 시스템 제거로 단순화

---

### Q: RAG 시스템에 TF-IDF를 사용한 이유와 한계는?

> **결정사항**: 초기 RAG 구현에 TF-IDF 벡터화 방식 채택
> 
> **선택 근거**:
> - **구현 단순성**: sklearn의 TfidfVectorizer 직접 활용
> - **의존성 최소화**: 외부 AI 모델 서비스 없이 구현 가능
> - **빠른 프로토타이핑**: MVP 단계에서 검증 용도
> 
> **발견된 한계점**:
> - **문서 길이 민감성**: 긴 문서가 항상 불리
> - **포화 효과 없음**: 단어 빈도가 무한정 증가 가능
> - **전체 재계산 필요**: 새 문서 추가 시 벡터 재계산
> 
> **향후 개선 방향**:
> - BM25 알고리즘으로 교체 권장
> - 문서 길이 정규화 및 포화 효과 적용
> - 15-30% 검색 정확도 향상 기대

---

### Q: Clean Architecture에서 LangChain Document 표준을 채택한 이유는?

> **결정사항**: 여러 데이터 모델 대신 LangChain Document로 통일
> 
> **통일 전 문제점**:
> - 각 계층별 다른 데이터 모델 사용
> - 변환 로직 복잡성 증가
> - 데이터 일관성 보장 어려움
> 
> **LangChain Document 선택 근거**:
> - **업계 표준**: RAG 시스템에서 널리 사용되는 표준
> - **호환성**: 다양한 벡터 저장소와 호환
> - **확장성**: 메타데이터 관리와 청킹 전략 지원
> - **생태계**: LangChain 에코시스템 활용 가능
> 
> **달성 효과**:
> - 단일 데이터 모델로 복잡성 감소
> - 새 파일 타입 추가 시 Factory에서만 수정
> - 각 계층별 독립적 단위 테스트 가능

---

## 템플릿 사용 가이드

이 문서는 실제 프로젝트에서 내린 기술적 의사결정들을 기록한 것입니다. 각 결정사항은:

- **구체적인 문제 상황**에서 출발
- **여러 대안들을 비교 검토**
- **정량적/정성적 근거**를 바탕으로 결정
- **실제 구현 결과와 효과**를 측정

새로운 의사결정이 있을 때는 비슷한 형식으로 기록하여 포트폴리오 자산으로 활용하세요.