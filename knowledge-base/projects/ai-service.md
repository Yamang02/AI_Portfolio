---
title: "AI 포트폴리오 RAG 챗봇"
document_type: "PROJECT"
year: 2025
skills: ["Hexagonal Architecture", "RAG", "Java", "Spring Boot", "Python", "FastAPI", "React", "Docker", "GCP Cloud Run", "CI/CD", "Qdrant", "Redis", "PostgreSQL", "Gemini API"]
keywords: ["포트폴리오", "챗봇", "풀스택", "AI-통합", "RAG 시스템", "마이크로서비스"]
summary: "헥사고날 아키텍처를 기반으로 RAG(검색 증강 생성) 파이프라인을 구축하여, 제 포트폴리오에 대해 자연어로 답변하는 AI 챗봇 시스템을 설계하고 개발했습니다."
---

## 프로젝트 목표 및 기획 의도

단순히 정보를 나열하는 포트폴리오를 넘어, 사용자와 상호작용하며 저의 기술적 깊이와 성장 과정을 효과적으로 보여줄 수 있는 AI 챗봇 시스템을 구축하는 것을 목표로 했습니다. 이 프로젝트를 통해 다음과 같은 역량을 확보하고 증명하고자 했습니다.

- **최신 AI 기술 활용 능력:** Google Gemini API와 RAG 파이프라인을 직접 설계하고 구현합니다.
- **안정적인 백엔드 아키텍처 설계:** 확장성과 유지보수성이 뛰어난 헥사고날 아키텍처를 실제 프로젝트에 적용합니다.
- **클라우드 기반 CI/CD 및 배포 자동화:** Docker와 Google Cloud Run, GitHub Actions를 활용하여 인프라를 구축하고 배포를 자동화합니다.
- **문제 해결 능력:** 개발 및 배포 과정에서 발생하는 다양한 기술적 문제를 분석하고 해결하는 과정을 기록하고 자산화합니다.

## 주요 역할 및 기여

이 프로젝트는 1인 개발로 진행되었으며, 저는 시스템의 모든 단계에 걸쳐 다음과 같은 역할을 주도적으로 수행했습니다.

- **아키텍처 설계:** 전체 시스템을 헥사고날 아키텍처(Ports & Adapters) 기반으로 설계했습니다. 도메인, 애플리케이션, 인프라 레이어를 명확히 분리하여 유연하고 테스트 가능한 구조를 만들었습니다.
- **RAG 파이프라인 구현:** 문서 로딩, 청킹, 임베딩, 벡터 검색, 답변 생성에 이르는 RAG의 전 과정을 직접 구현했습니다. 특히, 검색 품질을 높이기 위해 필터링과 유사도 검색을 결합하는 하이브리드 검색 전략을 도입했습니다.
- **백엔드 개발:** Java, Spring Boot, Python, FastAPI를 사용하여 API 서버와 AI 서비스를 개발했습니다. Qdrant 벡터 DB와 Redis 캐시를 연동하여 성능을 최적화했습니다.
- **인프라 및 DevOps:** Docker를 사용하여 애플리케이션을 컨테이너화하고, GitHub Actions로 CI/CD 파이프라인을 구축하여 Google Cloud Run에 자동으로 배포했습니다. Staging과 Production 환경을 분리하여 안정적인 운영 환경을 구성했습니다.

## 프로젝트 발전 과정 (Timeline)

- **2025년 7월 (초기 MVP 개발):**
  - Express.js 기반의 간단한 백엔드 서버와 React 프론트엔드로 초기 프로토타입을 구현했습니다.
  - 이 시기에는 히스토리 패널, 프로젝트 타입 구분 등 핵심 UI 기능 개발에 집중했습니다.
  - API 키 노출 문제를 해결하기 위해 백엔드를 분리하는 등 초기 아키텍처 개선 작업을 진행했습니다.

- **2025년 8월 (아키텍처 고도화 및 RAG 도입):**
  - **(08.12)** 유지보수성과 확장성을 높이기 위해 FSD(Feature-Sliced Design) 아키텍처를 프론트엔드에 도입했습니다.
  - **(08.20)** 백엔드 전체를 **헥사고날 아키텍처**로 리팩토링하여 도메인 로직과 인프라를 완전히 분리했습니다. 또한, Staging과 Production 환경에 차별화된 CI/CD 전략을 도입하여 배포 안정성을 확보했습니다.
  - **(08.22)** 채팅 응답 속도 개선을 위해 **Redis Cloud 기반의 캐시 시스템**을 도입하고, TTL 및 캐시 키 전략을 수립했습니다.
  - **(08.25)** **Docker 빌드 최적화**를 진행하여 재빌드 시간을 1~2분으로 단축시켰고, Qdrant 벡터DB 연동을 위한 환경변수 설정을 표준화했습니다.

## 기술적 결정 및 배운 점

- **헥사고날 아키텍처 채택:** 처음에는 전통적인 레이어드 아키텍처로 시작했으나, AI 로직과 비즈니스 로직의 의존성이 높아지는 문제를 해결하기 위해 헥사고날 아키텍처로 리팩토링했습니다. 이를 통해 각 컴포넌트의 단일 책임 원칙을 지키고, Mock 어댑터를 활용한 단위 테스트의 용이성을 확보했습니다.
- **CI/CD 환경 분리:** Staging과 Production 환경의 CI/CD 파이프라인과 데이터베이스 권한을 분리하는 전략을 채택했습니다. 이를 통해 개발 및 테스트의 속도와 운영 환경의 안정성이라는 두 마리 토끼를 잡을 수 있었습니다.
- **Docker 빌드 실패 경험:** 수차례의 Docker 빌드 실패를 경험하며, 빌드 컨텍스트, `.dockerignore` 파일의 동작 방식, 레이어 캐시 최적화 등 Docker의 내부 동작 원리에 대해 깊이 이해하게 되었습니다. 이는 결국 안정적인 배포 환경을 구축하는 밑거름이 되었습니다.

## 핵심 Q&A

**Q: 백엔드는 어떤 아키텍처 패턴을 사용하나요?**

A: 헥사고날 아키텍처(Ports and Adapters)를 적용했습니다. 도메인 로직을 중심으로 하고 외부 의존성을 포트와 어댑터로 분리하여 테스트 가능성과 유지보수성을 향상시켰습니다. 주요 구성요소는 Domain(핵심 로직), Application(유스케이스), Infrastructure(외부 시스템 어댑터)로 나뉩니다.

**Q: RAG(검색 증강 생성) 시스템은 어떻게 구현했나요?**

A: 벡터 검색 기반의 RAG 파이프라인을 구축했습니다. 과정은 (1)사용자 질문 분석, (2)Qdrant에서 유사 문서 검색, (3)검색된 정보로 프롬프트 구성, (4)Gemini API로 최종 답변 생성, (5)Redis에 결과 캐싱 순으로 진행됩니다.

**Q: 벡터 데이터베이스로 Qdrant를 선택한 이유는 무엇인가요?**

A: Qdrant Cloud의 프리티어를 활용할 수 있고, GCP의 Region도 연계 가능했기 때문에 선택했습니다. 

**Q: CI/CD 파이프라인은 어떻게 구성되어 있나요?**

A: GitHub Actions를 기반으로 자동화했습니다. 코드가 푸시되면 Docker 이미지를 빌드하고, 단위/통합 테스트를 실행한 후, Staging 또는 Production 환경의 Railway에 자동으로 배포됩니다.